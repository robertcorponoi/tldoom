import React, { useEffect, useRef } from "react";
import {
	Geometry2d,
	HTMLContainer,
	Rectangle2d,
	resizeBox,
	ShapeUtil,
	TLBaseShape,
	TLResizeInfo,
} from "tldraw";

import { useScript } from "./useScript";

/**
 * The type definition for our custom tldoom shape.
 */
type ITLDoomShape = TLBaseShape<
	"doom",
	{
		/**
		 * The width of the shape.
		 */
		w: number;
		/**
		 * The height of the shape.
		 */
		h: number;
	}
>;

/**
 * A utility class for the tldoom shape. This is where we define the shape's
 * behavior, how it renders (its component and indicator), and how it handles
 * different events.
 */
export class TLDoomShapeUtil extends ShapeUtil<ITLDoomShape> {
	/**
	 * The type of the shape, it's name.
	 */
	static override type = "doom" as const;

	/**
	 * Indicates that the shape is resizable.
	 *
	 * @returns {boolean}
	 */
	override canResize(): boolean {
		return true;
	}

	/**
	 * When the shape is resized, change the canvas size.
	 *
	 * **Note:** This doesn't update the size of the game contents, not sure
	 * why.
	 *
	 * @param {ITLDoomShape} shape The shape.
	 * @param {TLResizeInfo<ITLDoomShape>} info Information about the resize event.
	 *
	 * @returns {ITLDoomShape|undefined}
	 */
	override onResize(
		shape: ITLDoomShape,
		info: TLResizeInfo<ITLDoomShape>
	): ITLDoomShape | undefined {
		// Get our canvas element by its id. This is outside of the React
		// component for the shape so we can't use its ref.
		const canvas = document.getElementById("canvas");
		if (!canvas) return;

		// Resize the tldraw shape.
		const resized = resizeBox(shape, info);

		// Resize the canvas from emscripten.
		window.Browser.setCanvasSize(resized.props.w, resized.props.h);

		return resized;
	}

	/**
	 * Lock the aspect ratio so it stays consistent when resizing.
	 *
	 * @returns {boolean}
	 */
	override isAspectRatioLocked(): boolean {
		return true;
	}

	/**
	 * Returned when the shape is hovered over or when it's selected. This
	 * must return a SVG element.
	 *
	 * @param {ITLDoomShape} shape The shape.
	 *
	 * @returns {React.ReactElement} The indicator.
	 */
	indicator(shape: ITLDoomShape): React.ReactElement {
		return <rect width={shape.props.w} height={shape.props.h} />;
	}

	/**
	 * The default props that the shape will be rendered with when
	 * click-creating one.
	 *
	 * @returns {ITLDoomShape["props"]} The default props.
	 */
	getDefaultProps(): ITLDoomShape["props"] {
		return {
			w: 320,
			h: 200,
		};
	}

	/**
	 * Calculates the shape's geometry for hit-testing, bindings, and doing
	 * other geometric calculations.
	 *
	 * @param {ITLDoomShape} shape The shape.
	 *
	 * @returns {Geometry2d} The shape's geometry.
	 */
	getGeometry(shape: ITLDoomShape): Geometry2d {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: true,
		});
	}

	/**
	 * The render method - the React component that will be rendered for the
	 * shape. It takes the shape as an argument. `HTMLContainer` is just a
	 * `div` that's being used to wrap our shape. We can get the shape's
	 * bounds usinig our own `getGeometry` method.
	 *
	 * The contents of this can be treated as a React component. Any hooks
	 * can be used here.
	 *
	 * @param {ITLDoomShape} shape The shape.
	 */
	component(shape: ITLDoomShape) {
		/**
		 * A ref to the canvas element the game is displayed on. This is
		 * returned from the `canvas` property of the `Module` so that
		 * emscripten add listeners, etc. to the canvas.
		 */
		// We disable the rule of hooks because ESLint doesn't know that this
		// is a functional React component, not a class one.
		// eslint-disable-next-line react-hooks/rules-of-hooks
		const canvasRef = useRef<HTMLCanvasElement | null>(null);

		/**
		 * Defines the `Module` used by emscripten as configuration.
		 */
		// Disable the rule of hooks for the same reason as listed above.
		// eslint-disable-next-line react-hooks/rules-of-hooks
		useEffect(() => {
			window.Module = {
				preRun: [
					function () {
						window.SDL.defaults.copyOnLock = false;
					},
				],
				canvas: (function () {
					return canvasRef.current;
				})(),
			};
		}, []);

		/**
		 * Adds the script generated by emscripten for running the game to the
		 * DOM if it doesn't exist already. This should only add it once.
		 */
		// Disable the rule of hooks for the same reason as listed above.
		// eslint-disable-next-line react-hooks/rules-of-hooks
		useScript("./index.js", { removeOnUnmount: true });

		return (
			<HTMLContainer
				id={shape.id}
				style={{
					display: "flex",
					flexDirection: "column",
					alignItems: "center",
					justifyContent: "center",
					pointerEvents: "all",
				}}
			>
				<canvas
					id="canvas"
					ref={canvasRef}
					onContextMenu={(event) => event.preventDefault()}
					tabIndex={-1}
					style={{
						border: 0,
						backgroundColor: "black",
						imageRendering: "pixelated",
					}}
				/>
			</HTMLContainer>
		);
	}
}
